<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Slime Time</title>
  <link rel="stylesheet" href="css/main.css">
  <style>
    #blocker {
				position: absolute;
				width: 100%;
				height: 100%;
				background-color: rgba(0,0,0,0.5);
			}

			#instructions {
				width: 100%;
				height: 100%;

				display: -webkit-box;
				display: -moz-box;
				display: box;

				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;

				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;

				color: #ffffff;
				text-align: center;
				font-family: Arial;
				font-size: 14px;
				line-height: 24px;

				cursor: pointer;
			}
  </style>
</head>
<body>

  <div id="blocker">

    <div id="instructions">
      <span style="font-size:36px">Click to play</span>
      <br /><br />
      Move: WASD<br/>
      Jump: SPACE<br/>
      Look: MOUSE
    </div>

  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r123/three.js"></script>
  <script src='./node_modules/three/examples/jsm/utils/threex.domevents.js'></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.70/Tone.js"></script>
  <script src="./js/obj.js"></script>
  <script src="./js/mtl.js"></script>
  <script src="./js/physi.js"></script>
  <script src="./js/perlin_noise.js"></script>


  <script type="module">
    // import { OrbitControls } from './node_modules/three/examples/jsm/controls/OrbitControls.js';
    // import { FirstPersonControls } from './node_modules/three/examples/jsm/controls/FirstPersonControls.js';
    import { PointerLockControls } from './node_modules/three/examples/jsm/controls/PointerLockControls.js';
    import { GLTFLoader } from './node_modules/three/examples/jsm/loaders/GLTFLoader.js';


    Physijs.scripts.worker = './js/physijs_worker.js'
    Physijs.scripts.ammo = 'https://chandlerprall.github.io/Physijs/examples/js/ammo.js';
    
    var scene = new Physijs.Scene;
    scene.setGravity(new THREE.Vector3(0,-1000,0));

    const objects = []

    var camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
    camera.position.set(-200,200,5000)

    var clock = new THREE.Clock();

    var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setClearColor("#007a33");
    renderer.setSize(window.innerWidth,window.innerHeight);
    document.body.appendChild(renderer.domElement); 

    // var controls = new PointerLockControls( camera, renderer.domElement );
				// controls.movementSpeed = 1500;
				// controls.lookSpeed = 0.1;
        // controls.verticalMin = 0;
        // controls.minDistance = -900;
        // controls.maxDistance = 20000;
        // controls.enableDamping = true;
        // controls.dampingFactor = 0.27;

      let moveForward = false;
			let moveBackward = false;
			let moveLeft = false;
			let moveRight = false;
			let canJump = false;

			let prevTime = performance.now();
			const velocity = new THREE.Vector3();
			const direction = new THREE.Vector3();
			const vertex = new THREE.Vector3();
			const color = new THREE.Color();
        
    var controls = new PointerLockControls( camera, document.body );

    const blocker = document.getElementById( 'blocker' );
    const instructions = document.getElementById( 'instructions' );

    instructions.addEventListener( 'click', function () {

      controls.lock();

    }, false );

    controls.addEventListener( 'lock', function () {

      instructions.style.display = 'none';
      blocker.style.display = 'none';

    } );

    controls.addEventListener( 'unlock', function () {

      blocker.style.display = 'block';
      instructions.style.display = '';

    } );

    scene.add( controls.getObject() );

    const onKeyDown = function ( event ) {

      switch ( event.keyCode ) {

        case 38: // up
        case 87: // w
          moveForward = true;
          break;

        case 37: // left
        case 65: // a
          moveLeft = true;
          break;

        case 40: // down
        case 83: // s
          moveBackward = true;
          break;

        case 39: // right
        case 68: // d
          moveRight = true;
          break;

        case 32: // space
          if ( canJump === true ) velocity.y += 350;
          canJump = false;
          break;

      }

    };

    const onKeyUp = function ( event ) {

      switch ( event.keyCode ) {

        case 38: // up
        case 87: // w
          moveForward = false;
          break;

        case 37: // left
        case 65: // a
          moveLeft = false;
          break;

        case 40: // down
        case 83: // s
          moveBackward = false;
          break;

        case 39: // right
        case 68: // d
          moveRight = false;
          break;

      }

    };

    document.addEventListener( 'keydown', onKeyDown, false );
    document.addEventListener( 'keyup', onKeyUp, false );
    document.addEventListener( 'click', function() {
          
          console.log( 'click' );
                
      } );


    var raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );

    
    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth,window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.outputEncoding = THREE.sRGBEncoding;
      // controls.handleResize();
    })


    var light = new THREE.HemisphereLight( 0xFFFFFF, 0xffffff, 0.75 )
    light.position.set(0,15,0);
    scene.add(light);

    var light = new THREE.PointLight(0xFFFFFF, 2, 500)
    light.position.set(0,100,35);
    scene.add(light);

    const grass = new THREE.TextureLoader().load('./grass.jpg');

    function createTerrain(){

    var ground_material = Physijs.createMaterial(
      new THREE.MeshLambertMaterial({
        map: grass
      }),
      0.1,
      10
    )


    var balue = -400

    var ground_geometry = new THREE.PlaneGeometry(2400,2200,100,100)
    

    for (var i=0; i<ground_geometry.vertices.length; i++){
      var vertex = ground_geometry.vertices[i];
      // if ((vertex.x%10 ==0) | (vertex.y%10==0)){
      //   balue = 25;
      // } else {
      //   balue = 0;
      // }
      balue = noise.simplex2(vertex.x/10,vertex.y/10)
      vertex.z = Math.abs(balue)*75;
      // vertex.z = balue
    }

    ground_geometry.computeFaceNormals();
    ground_geometry.computeVertexNormals();

    var ground  = new Physijs.HeightfieldMesh(
      ground_geometry,
      ground_material,
      0,
      100,
      100
    )
    ground.position.y = -200
    ground.scale.set(5,5,5)
    ground.rotation.x = Math.PI / -2 ;

    return ground

    }
    scene.add(createTerrain())

    // var count = 500
    // var scale = 2000
    const texture = new THREE.TextureLoader().load( './SL2.jpg' );

    // for ( let i = 0; i < count; i ++ ) {

    // const geometry66 = new THREE.SphereGeometry(100,20,10)
    // const material66 = new THREE.MeshBasicMaterial({map: texture})
    

    // const r = Math.random() * 1.2 * Math.PI;
    // const z = ( Math.random() * 2.0 ) - 1.0;
    // const zScale = Math.sqrt( 1.0 - z * z ) * scale;

    // const bun = new THREE.Mesh(geometry66, material66)
    // bun.position.set(
    //   Math.cos( r ) * zScale,
    //   Math.sin( r ) * zScale,
    //   z * scale
    // );
    // bun.rotation.set( Math.random(), Math.random(), Math.random() );
    // scene.add( bun );
    // console.log
    // }


    // const map = new THREE.TextureLoader().load( 'SL2.jpg' );
    // const spriteMaterial = new THREE.SpriteMaterial( { map: map } );

    // const sprite = new THREE.Sprite( spriteMaterial );
    // scene.add( sprite );
    // sprite.position.set(2000,2000,-2000)
    // sprite.scale.set(900,900,1)

    function add_sphere(){
    const geometry9 = new THREE.SphereGeometry(200, 33, 33)
    const material9 = new THREE.MeshPhongMaterial({map: texture, side: THREE.DoubleSide})
    const universe = new Physijs.SphereMesh(geometry9, material9)
    universe.position.x = (50*Math.random())*50;
    universe.position.z = 50*Math.random();
    universe.position.y = 3000 
    scene.add(universe)
    }
    
   

    // const geometry7 = new THREE.SphereGeometry(2000, 33, 33)
    // const material7 = new THREE.MeshPhongMaterial({map: texture, side: THREE.DoubleSide})
    // const blender = new Physijs.SphereMesh(geometry7, material7)
    // blender.position.set(0,10000,0)
    // scene.add(blender)

    // var geo = new THREE.PlaneBufferGeometry(8000, 8000, 8, 8);
    // const mat = new THREE.MeshPhongMaterial({color: '#4ff904', side: THREE.DoubleSide });
    // var plane = new Physijs.BoxMesh(geo, mat);
    // plane.rotateX( - Math.PI / 2);
    // plane.position.set(0, -125, 0)
    // scene.add(plane);
  
    // var beo = new THREE.BoxBufferGeometry(8000, 8000, 8, 8);
    // const bat = new THREE.MeshBasicMaterial({map: texture, side: THREE.DoubleSide });
    // var plane = new THREE.Mesh(beo, bat);
    // plane.rotateZ( - Math.PI / 2);
    // plane.rotation.z = - Math.PI * 2.0;
    // plane.position.set(0, 3275, -8000)
    // scene.add(plane);

    // var ceo = new THREE.PlaneBufferGeometry(800, 800, 8, 8);
    // const cat = new THREE.MeshPhongMaterial({color: '#4ff904', side: THREE.DoubleSide });
    // var plane = new THREE.Mesh(ceo, cat);
    // plane.rotateY( - Math.PI / 2);
    // plane.position.set(400, 275, 0)
    // scene.add(plane);

    // var deo = new THREE.PlaneBufferGeometry(800, 800, 8, 8);
    // const dat = new THREE.MeshPhongMaterial({color: '#4ff904', side: THREE.DoubleSide });
    // var plane = new THREE.Mesh(deo, dat);
    // plane.rotateY( - Math.PI / 2);
    // plane.position.set(-400, 275, 0)
    // scene.add(plane);

    // var feo = new THREE.PlaneBufferGeometry(800, 800, 8, 8);
    // const fat = new THREE.MeshPhongMaterial({color: '#4ff904', side: THREE.DoubleSide });
    // var plane = new THREE.Mesh(feo, fat);
    // plane.rotateX( - Math.PI / 2);
    // plane.position.set(0, 675, 0)
    // scene.add(plane);



    scene.fog = new THREE.Fog( 0x4ff904, 0, 11000 );
    

    var young;
    var stoner;
    var life;
        

    const loader = new GLTFLoader();

    loader.load(
      // resource URL
      './scene.gltf',
      // called when the resource is loaded
      function ( gltf ) {
        scene.add( gltf.scene );
        gltf.scene.position.set(200,-100,0)
        gltf.scene.scale.set(10,10,10)
        gltf.scene.color = "#000000"
    })

    loader.load(
      // resource URL
      './scene.gltf',
      // called when the resource is loaded
      function ( gltf ) {
        scene.add( gltf.scene );
        gltf.scene.position.set(20,-100,0)
        gltf.scene.scale.set(10,10,10)
    })

    loader.load(
      // resource URL
      './scene.gltf',
      // called when the resource is loaded
      function ( gltf ) {
        scene.add( gltf.scene );
        gltf.scene.position.set(-170,-100,0)
        gltf.scene.scale.set(10,10,10)
    })

    

    var mtlLoader = new THREE.MTLLoader();
    mtlLoader.load('Y.mtl', function (materials) {


      materials.preload();

      var objLoader = new THREE.OBJLoader();
      objLoader.setMaterials(materials);
      objLoader.load('Y.obj', function (object) {
        scene.add(object);
        young = object;
        object.position.z = 33;
        object.position.y = 5;
        object.position.x = -200;
        object.rotation.z = 0;
        object.scale.set(1.15,1.15,1.15)
      });
    });

    var mtlLoader = new THREE.MTLLoader();
    mtlLoader.load('S.mtl', function (materials) {


      materials.preload();

      var objLoader = new THREE.OBJLoader();
      objLoader.setMaterials(materials);
      objLoader.load('S.obj', function (object) {
        scene.add(object);
        stoner = object;
        object.position.z = 33;
        object.position.y = 5
        object.position.x = 0;
        object.rotation.z = 0;
      });
    });

    var mtlLoader = new THREE.MTLLoader();
    mtlLoader.load('L.mtl', function (materials) {


      materials.preload();

      var objLoader = new THREE.OBJLoader();
      objLoader.setMaterials(materials);
      objLoader.load('L.obj', function (object) {
        scene.add(object);
        life = object;
        object.position.z = 33;
        object.position.y = 10;
        object.position.x = 180;
        object.rotation.z = 0;
      });
    });

    // const geometry10 = new THREE.TorusKnotBufferGeometry( 2000, 220.3, 128, 64 )
    // const material10 = new THREE.MeshPhongMaterial({color: "#ff0000", side: THREE.BacksSide})
    // const snake = new THREE.Mesh(geometry10, material10)
    // snake.position.set(0,0,0)
    // snake.rotation.x = 5
    // console.log(snake.geometry.parameters)
    // scene.add(snake)

    // const geometry11 = new THREE.TorusKnotBufferGeometry( 2000, 220.3, 128, 64 )
    // const material11 = new THREE.MeshPhongMaterial({color: "#ff0000", side: THREE.BacksSide})
    // const snake2 = new THREE.Mesh(geometry11, material11)
    // snake2.position.set(0,0,0)
    // scene.add(snake2)
   
    // const geometry12 = new THREE.TorusKnotBufferGeometry( 2000, 220.3, 128, 64 )
    // const material12 = new THREE.MeshPhongMaterial({color: "#ff0000", side: THREE.BacksSide})
    // const snake3 = new THREE.Mesh(geometry12, material12)
    // snake3.position.set(0,0,0)
    // snake3.rotation.y = -2
    // scene.add(snake3)

    const geometry = new THREE.SphereGeometry(20, 20, 20)
    const material = new THREE.MeshPhongMaterial({color: '#ff0000'})
    const mercury = new THREE.Mesh(geometry, material)
    mercury.position.set(0,300,0)
    scene.add(mercury)

    const geometry2 = new THREE.SphereGeometry(20, 20, 20)
    const material2 = new THREE.MeshPhongMaterial({color: "#ff0000"})
    const moon = new THREE.Mesh(geometry2, material2)
    moon.position.set(180,300,0)
    scene.add(moon)

    const geometry3 = new THREE.SphereGeometry(20, 20, 20)
    const material3 = new THREE.MeshPhongMaterial({color: "#ff0000"})
    const mars = new THREE.Mesh(geometry3, material3)
    mars.position.set(-200,300,0)
    scene.add(mars)

    const geometry4 = new THREE.SphereGeometry(100,100,100)
    const material4 = new THREE.MeshBasicMaterial({color: "#000000"})
    const sun = new THREE.Mesh(geometry4, material4)
    sun.position.set(0,520,0)
    scene.add(sun)


    const backsound = new Tone.Player("./hbsLoop.mp3").toDestination();
    Tone.loaded().then(() => {
      Tone.context.resume();
    });

    const player = new Tone.Player("./fed.mp3").toDestination();
    // const player1 = new Tone.Player("./fed.mp3").toDestination();
    const player2 = new Tone.Player("./grat.mp3").toDestination();
    
    const domEvents = new THREEx.DomEvents(camera, renderer.domElement)

    

    function loopSwitch() {
      backsound.volume.value = -10;
        if (backsound.state == "started") {
            // Use the Tone.Transport to pause audio
            backsound.stop();
        } else if (backsound.state == "stopped") {
            // Use the Tone.Transport to start again
            backsound.start();
    }}

  
    domEvents.addEventListener(sun, 'click', event => {
      loopSwitch();
    })

    domEvents.addEventListener(sun, 'mouseover', event => {
      sun.material.color.setHex( 0xffffff );
    })

    domEvents.addEventListener(sun, 'mouseout', event => {
      sun.material.color.setHex( 0x000000 );
    })

    domEvents.addEventListener(mercury, 'click', event => {
      player.start();
    })
    domEvents.addEventListener(moon, 'click', event => {
      // moon.scale.set(5,5,5)
      player2.start();
    })

    Tone.context.resume();
    
    domEvents.addEventListener(mars, 'click', event => {
      // mars.scale.set(15,15,15)
      player2.start();
    })

    // function keyLog() {
    //   document.onkeydown = function(e) {
       
    //   }
    // }
    // keyLog()

    // var controls = new OrbitControls( camera, renderer.domElement );
    // controls.minDistance = -900
    // controls.maxDistance = 20000
    // controls.enableDamping = true;
    // controls.dampingFactor = 0.27;
    // controls.target = new THREE.Vector3(0,0,-100);
    // var centerPosition = controls.target.clone();
    // centerPosition.y = 0;
    // var groundPosition = camera.position.clone();
    // groundPosition.y = 0;
    // var d = (centerPosition.distanceTo(groundPosition));

    // var origin = new THREE.Vector2(controls.target.y,0);
    // var remote = new THREE.Vector2(0,d); // replace 0 with raycasted ground altitude
    // var angleRadians = Math.atan2(remote.y - origin.y, remote.x - origin.x);
    // controls.maxPolarAngle = angleRadians;
    
//     document.addEventListener("keydown", onDocumentKeyDown, false);
//     function onDocumentKeyDown(event) {
//     var keyCode = event.which;
//     // up
//     if (keyCode == 40) {
//         camera.position.z += 5;
//         // down
//     } else if (keyCode == 38) {
//         camera.position.z -= 5;
//         // left
//     } else if (keyCode == 37) {
//         camera.position.x -= 5;
//         // right
//     } else if (keyCode == 39) {
//         camera.position.x += 5;
//         // space
//     } else if (keyCode == 32) {
//         camera.position.x = 0.0;
//         camera.position.y = 0.0;
//     }
//     // render();
// };




    var r = 333;
    var theta = 0.2;
    var dTheta = 2 * Math.PI / 1000;
    var step = 0;
  

    const animate = () => { 
      step += 1

      const time = performance.now();
      
      if ( controls.isLocked === true ) {
        raycaster.ray.origin.copy( controls.getObject().position );
        raycaster.ray.origin.y -= 10;

        const intersections = raycaster.intersectObjects( objects );

        const onObject = intersections.length > 0;

        const delta = ( time - prevTime ) / 1000;

        velocity.x -= velocity.x * 1.0 * delta;
        velocity.z -= velocity.z * 1.0 * delta;

        velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

        direction.z = Number( moveForward ) - Number( moveBackward );
        direction.x = Number( moveRight ) - Number( moveLeft );
        direction.normalize(); // this ensures consistent movements in all directions

        if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
        if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;

        if ( onObject === true ) {

          velocity.y = Math.max( 0, velocity.y );
          canJump = true;

        }

        controls.moveRight( - velocity.x * delta );
        controls.moveForward( - velocity.z * delta );

        controls.getObject().position.y += ( velocity.y * delta ); // new behavior

        if ( controls.getObject().position.y < 10 ) {

          velocity.y = 0;
          controls.getObject().position.y = 10;

          canJump = true;

        }

        }

        prevTime = time;

      // young.position.y += 0.10 
      // stoner.position.y += 0.20
      // life.position.y += 0.30
      mercury.rotation.z -= 0.01
      mercury.rotation.x -= 0.01

      // theta += dTheta;
      // moon.position.x = r * Math.cos(theta)
      // moon.position.z = r * Math.sin(theta)
      // mercury.position.x = r * Math.cos(theta) 
      // mercury.position.z = (r * Math.sin(theta))
      // mars.position.x = r * Math.cos(theta) 
      // mars.position.z = (r * Math.sin(theta) * -1)
      

      moon.rotation.x += 0.01
      moon.rotation.z += 0.01

      mars.rotation.x += 0.01
      mars.rotation.y += 0.01
      // snake.rotation.y += 0.01
      // snake2.rotation.z += 0.01
      // snake3.rotation.x += 0.01

      if (step % 50 == 0){
        add_sphere();
      }

      // controls.update( clock.getDelta() );
      scene.simulate();

      requestAnimationFrame(animate)
      renderer.render(scene, camera)
  
    }

    animate()
    

    
  </script>
</body>
</html>